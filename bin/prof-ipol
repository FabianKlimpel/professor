#! /usr/bin/env python

import optparse
op = optparse.OptionParser()
opts, args = op.parse_args()

def read_paramsfile(path):
    rtn = {}
    with open(path, "r") as f:
        for line in f:
            parts = line.split("#")[0].strip().split()
            assert len(parts) == 2
            rtn[parts[0]] = float(parts[1])
    return rtn

import os, glob
INDIR = args[0]
indirs = glob.glob(os.path.join(INDIR, "mc", "*"))

import yoda
PARAMS = {} # run -> pdict
HISTOS = {} # name -> run -> yhist
for d in indirs:
    run = os.path.basename(d)
    pf = glob.glob(os.path.join(d, "used_params"))[0]
    PARAMS[run] = read_paramsfile(pf)
    yfs = glob.glob(os.path.join(d, "*.yoda"))
    for yf in yfs:
        s2s = [ao.mkScatter() for ao in yoda.read(yf, asdict=False)]
        for s2 in s2s:
            HISTOS.setdefault(s2.path, {})[run] = s2

RUNS = sorted(PARAMS.keys())
PARAMNAMES = sorted(PARAMS[RUNS[0]].keys())
PARAMSLIST = [[params[pn] for pn in PARAMNAMES] for (run, params) in sorted(PARAMS.iteritems())]
print RUNS
print PARAMNAMES
print PARAMSLIST


class IpolBin(object):
    def __init__(self, xmin, xmax, ival=None, ierr=None):
        self.xmin = xmin
        self.xmax = xmax
        self.ival = ival
        self.ierr = ierr

    def val(self, params):
        return self.ival.value(params)

    def err(self, params):
        return self.ierr.value(params)

    def __cmp__(self, other):
        return cmp(self.xmin, other.xmin)

class IpolHisto(object):
    def __init__(self, bins=None):
        self.bins = bins if bins else []


import professor2 as prof
HNAMES = HISTOS.keys()
IHISTOS = {}
for hn in HNAMES:
    print "Interpolating " + hn
    histos = HISTOS[hn]
    nbins = len(histos[RUNS[0]].points)
    bins = []
    for n in xrange(nbins):
        vals = [histos[run].points[n].y for run in RUNS]
        ipol = prof.Ipol(PARAMSLIST, vals, 3)
        xmin = histos[RUNS[0]].points[n].xMin
        xmax = histos[RUNS[0]].points[n].xMax
        bins.append(IpolBin(xmin, xmax, ipol))
    IHISTOS[hn] = IpolHisto(bins)
    del HISTOS[hn] #< pro-actively clear up memory
del HISTOS #< more memory clean-up

#print sum(len(h.bins) for h in IHISTOS.values())

# TODO: write out a histo bins interpolation file
for hname, ih in IHISTOS.iteritems():
    for i, ib in enumerate(ih.bins):
        print ib.ival.toString(hname+":"+str(i))


import numpy as np
A_X = np.linspace(min(ps[0] for ps in PARAMSLIST), max(ps[0] for ps in PARAMSLIST), 20)
A_Y = np.linspace(min(ps[1] for ps in PARAMSLIST), max(ps[1] for ps in PARAMSLIST), 20)
M_X, M_Y = np.meshgrid(A_X, A_Y)
M_Z = np.zeros(M_X.shape)
ih = IHISTOS.values()[0] #< TODO: remove one-histo hack
for i in xrange(M_X.shape[0]):
    for j in xrange(M_X.shape[1]):
        for ib in ih.bins:
            M_Z[i,j] += ib.val([M_X[i,j], M_Y[i,j]]) #< TODO: something better, e.g. a simple chi2


import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
# ax.scatter(X1, Y1, Z1, c="r")
ax.plot_wireframe(M_X, M_Y, M_Z, rstride=1, cstride=1)
plt.show()
