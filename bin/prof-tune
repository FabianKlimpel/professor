#! /usr/bin/env python

"""\
%prog [opts] <refdir> [<ipolfile>=ipol.dat]

Use the interpolations stored in <ipolfile> to find optimised parameters with
the reference histograms found in the <refdir> as the optimisation target.

TODO:
 * Handle weight files/args
 * Handle run combination file/string (write a hash of the run list into the ipol filename?)
"""

import optparse
op = optparse.OptionParser(usage=__doc__)
op.add_option("--output", dest="OUTPUT", default="tuned", help="Prefix for outputs (default: %default)")
op.add_option("--limits", dest="LIMITS", default=None, help="Simple text file with parameter limits and fixed parameters")
# TODO: Really a core feature? Define "pull". REMOVE
# op.add_option("--pulls", dest="PULLS", action="store_true", default=False, help="Output pull histograms after minimisation")
# TODO: Add weight file parsing to decide which histos (and bin subsets) to interpolate
op.add_option("--debug", dest="DEBUG", action="store_true", default=False, help="Turn on some debug messages")
op.add_option("--quiet", dest="QUIET", action="store_true", default=False, help="Turn off messages")
opts, args = op.parse_args()

## Load Professor and show the standard banner
import professor2 as prof
if not opts.QUIET:
    print prof.logo


## Extract mandatory arguments
RUNSDIR = args[0]
IFILE = "ipol.dat"
if len(args) == 2:
    IFILE = args[1]


## Read persisted interpolations to re-create the ipol Histos
metadata = prof.read_meta(IFILE)
if not metadata["DataFormat"] == 'binned':
    print "Error, DataFormat of tuning input is not binned, exiting"
    import sys
    sys.exit(1)

## Read in ipol histos
IHISTOS = prof.read_binnedipol(IFILE)

## List of rivet analysis paths in IHISTOS
# TODO: Ick! We should avoid noise-code like this
ananames = list(set([filter(lambda x:len(x)>1, i.split("/"))[0] for i in IHISTOS.keys()]))

## Read reference data histos
import os, glob
HISTOS = {}
reffiles = glob.glob(os.path.join(RUNSDIR,  "*"))
for rf in reffiles:
    HISTOS.update(prof.read_histos(rf))

## Find things available in both
available=[]
for i in IHISTOS.keys():
    for r in HISTOS.keys():
        if i in r:
            available.append([i,r])

## Prepare list of ibins and databins --- order should be ok
ibins = []
databins = []
for a in available:
    ibins.extend(  IHISTOS[a[0]].bins)
    databins.extend(HISTOS[a[1]].bins)

## Sanity checks
assert(len(ibins) == len(databins))

if len(ibins)==0:
    print "No bins ..., exiting"
    import sys
    sys.exit(1)

weights=None
def simpleGOF(params):
    """
    Very straight forward gof
    """
    chi2 = 0.0
    for num, ibin in enumerate(ibins):
        ival = ibin.val(params)
        dval = databins[num].val
        if ibin.ierrs is None:
            err2 = databins[num].err**2
        else:
            err2 = sum([e**2 for e in ibin.ierrs])
        if err2 == 0.0:
            err2=1.
            #continue
        w=1
        if weights is not None:
            w=weights[num]
            pass # do stuff
        diff = dval - ival
        chi2 += w * diff**2 / err2
    return chi2


## Take parameter names directly from ifile
mpnames = ["'%s'"%x for x in metadata["Params"].split()]

## Fall back solution if empty
#if len(mpnames)==0:
mpnames = ["MP%03i"%(i) for i in xrange(int(metadata["Dimension"]))]

## Function definition wrapper
funcdef = prof.mk_fitfunc("simpleGOF", mpnames)
exec funcdef in locals()
if opts.DEBUG:
    print "Built GoF wrapper from:\n  '%s'" % funcdef


## Ignition
# TODO: Use the internal iminuit/PyMinuit(2) wrapper
from minuit2 import Minuit2 as Minuit
minuit = Minuit(profGoF, strategy=2)

## Starting point --- use center
C = []
for num, m in enumerate(map(float, metadata["MinV"].split())):
    C.append(m+0.5*(float(metadata["MaxV"].split()[num])-m))
for num, name in enumerate(mpnames):
    minuit.values[name] = C[num]


## Fix parameters, set limits
limits, fixed = prof.read_limitsandfixed(opts.LIMITS)
for mp in mpnames:
    if mp in limits.keys():
        minuit.limits[mp] = limits[mp]
    if mp in fixed.keys():
        minuit.values[mp] = fixed[mp]
        minuit.fixed[mp] = True

## Lift off
minuit.migrad()

## Goodness of fit
if not opts.QUIET:
    chi2 = minuit.fval
    ndof = len(databins) - len(mpnames) + len(fixed.keys())
    print "'chi2': %.2f"%chi2
    print "Ndof  : %i"%ndof
    print "G.o.f.: %.2f \n"%(chi2/ndof)

## Check if result is in validity range
result = [minuit.values[p] for p in mpnames]
rng_low = map(float, metadata["MinV"].split())
rng_high = map(float, metadata["MaxV"].split())
rok, rng = prof.is_inrange(result, rng_low, rng_high)

## Print results to screen
for num, p in enumerate(mpnames):
    isl, isf = " ", " "
    if opts.QUIET:
        print "%s\t%f"%(p, minuit.values[p])
    else:
        if p in fixed.keys():
            isf="F"
        if p in limits.keys():
            isl="L"
        if rok or not num in rng:
            print "%s\t%f\t%f\t%.2f %%   inside  (%f --- %f) %s %s"%(p, minuit.values[p], minuit.errors[p], 100*(minuit.errors[p]/minuit.values[p]), rng_low[num], rng_high[num], isf, isl)
        else:
            print "%s\t%f\t%f\t%.2f %%  OUTSIDE (%f --- %f) %s %s"%(p, minuit.values[p], minuit.errors[p], 100*(minuit.errors[p]/minuit.values[p]), rng_low[num], rng_high[num], isf, isl)


## Write out result
with open("%s_results.txt" % opts.OUTPUT,"w") as f:
    ## Meta info
    f.write("# ProfVersion: %s\n" % prof.mk_versionstring())
    f.write("# Date: %s\n" % prof.mk_timestamp())
    f.write("# InterpolationFile: %s\n" % os.path.abspath(IFILE))
    #f.write("# DataDir: %s\n" % os.path.abspath(RUNSDIR))
    # TODO: weights --- dump them all or just the file name? for consistency, probably better to dump them all at the end
    ## Limits
    lstring = ""
    for p in mpnames:
        if limits.has_key(p):
            lstring += "#\t%s\t%f %f\n"%(p, limits[p][0], limits[p][1])
    f.write("# Limits: \n%s" % lstring)
    # Fixed parameters
    fstring = ""
    for p in mpnames:
        if fixed.has_key(p):
            fstring += "#\t%s\t%f\n" % (p, fixed[p])
    f.write("# Fixed: \n%s" % fstring)

    ## The tuned parameter values
    for p in mpnames:
        f.write("%s\t%f\n" % (p, minuit.values[p]))

## Write out ipolhistos
result = [minuit.values[name] for name in mpnames]
with open("%s_ipolhistos.yoda" % opts.OUTPUT, "w") as f:
    for num, k in enumerate(sorted(IHISTOS.keys())):
        f.write(IHISTOS[k].toYODA(result, k))
        if num+1 < len(IHISTOS.keys()):
            f.write("\n")

# ## Pull histograms
# if opts.PULLS:
#     pulls = []
#     for a in available:
#         ikey=a[0]
#         dkey=a[1]
#         ib = IHISTOS[ikey].bins
#         db =  HISTOS[dkey].bins
#         pb = []
#         for i in xrange(len(ib)):
#             py = prof.pull(db[i], ib[i], result)
#             pb.append(prof.DataBin(db[i].xmin, db[i].xmax, py, 0))
#         pulls.append(prof.Histo(pb, ikey))

#     with open("%s_pulls.yoda"%opts.OUTPUT, "w") as f:
#         [f.write(h.toYODA()) for h in pulls]
