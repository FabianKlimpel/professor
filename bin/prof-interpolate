#!/usr/bin/env python

def readParams(fname):
    with open(fname) as f:
        A = sorted([i.strip().split() for i in f if not i.startswith("#") and not len(i.strip()) == 0])
    P = map(lambda x: float(x[1]), A)
    return P

def binIds(fname):
    from yoda import readYODA
    histos = filter(lambda x: x.type=="Histo1D" or x.type=="Profile1D", readYODA(fname).values())
    binids = []
    for h in histos:
        for num, b in enumerate(h.bins):
            binids.append( (h.path, num))
    return binids

def writeMeta(f, P):
    """
    Write some header info
    P is the list of anchor points
    """
    # http://stackoverflow.com/questions/13890935/timestamp-python
    import time
    ts = time.time()
    import datetime
    st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')
    f.write("# INFO Professor2.0 ProfDF (arXiv:0907.2973 [hep-ph])  %s \n"%st)
    f.write("# DIM %i\n"%len(P[0]))

    # Parameter edges
    from numpy import array
    p=array(P)
    minp = []
    maxp = []
    for i in xrange(len(P[0])):
        minp.append(min(p[:,i]))
        maxp.append(max(p[:,i]))

    f.write("# MINP")
    for i in minp:
        f.write(" %.10f"%i)
    f.write("\n")
    f.write("# MAXP")
    for i in maxp:
        f.write(" %.10f"%i)
    f.write("\n")

# http://stackoverflow.com/questions/24983493/tracking-progress-of-joblib-parallel-execution
from collections import defaultdict
class CallBack(object):
    completed = defaultdict(int)

    def __init__(self, index, parallel):
        self.index = index
        self.parallel = parallel

    def __call__(self, index):
        CallBack.completed[self.parallel] += 1
        import sys
        sys.stdout.write("\rDone with object {}".format(CallBack.completed[self.parallel]))
        sys.stdout.flush()
        if self.parallel._original_iterable:
            self.parallel.dispatch_next()


def defaultParam(ipols):
    import sys, time
    time1 = time.time()
    res = []
    for num, i in enumerate(ipols):
        res.append(i.toString())
        if ((num+1)%20 ==0):
            sys.stdout.write("\rObject %i/%i"%(num+1, len(ipols)))
            sys.stdout.flush()
    time2 = time.time()
    print '\nInterpolation took %0.2f s'%((time2-time1))
    return res

import argparse
parser = argparse.ArgumentParser(description='Parametrise and write out')
parser.add_argument('--mcdir', type=str, help='Directory with subruns')
parser.add_argument('--order', type=int, default=3, help='Order of polynomial for parametrisation')
parser.add_argument('--output', type=str, default="Coeffs.prof", help='Output file name')
parser.add_argument('--pfname', default="used_params", type=str, help='Parameter file name')
parser.add_argument("--threads", dest="THREADS", default=1, type=int, help="Number of threads to use")
args = parser.parse_args()


import glob, os
yodafiles = [x for x in glob.glob("%s/*/*yoda*"%args.mcdir) if args.pfname in os.listdir(os.path.dirname(x))]
goodruns = [os.path.dirname(y) for y in yodafiles]
print "Reading %i parameter points"%len(goodruns)
params = [readParams(os.path.join(x, args.pfname)) for x in goodruns]



binids = binIds(yodafiles[0])
hnames = list(set([x[0] for x in binids]))

from yoda import readYODA
print "Reading %i YODA files"%len(yodafiles)
import time
time1 = time.time()
histos = [readYODA(y) for y in yodafiles ]
time2 = time.time()
print '\nReading took %0.2f s'%((time2-time1))

from professor2 import Ipol
print "Preparing..."


ipols = []
badbins = []

import time
time1 = time.time()
# Iterate over analysis object paths
for hn in sorted(hnames):
    t=histos[-1][hn].type
    for n_b in xrange(len(histos[-1][hn].bins)):
        thebins = [histos[n_f][hn][n_b] for n_f in xrange(len(histos))]
        if t=="Histo1D":
            values = [x.height for x in thebins]
        else:
            try:
                values = [x.mean for x in thebins]
            except:
                badbins.append(n_b)
        if values:
            ipols.append(Ipol(params, values, args.order, hn+":%i"%n_b))
    for num in xrange(len(histos)):
        histos[num][hn] = 0


time2 = time.time()
print '\nPreparation took %0.2f s'%((time2-time1))


del histos

print "Parametrising %i objects..."%len(ipols)
# Get/set number of cpus to use
import multiprocessing
n_cpus = multiprocessing.cpu_count()
if args.THREADS > n_cpus:
    num_cores = n_cpus
else:
    num_cores = args.THREADS

if num_cores > 1:
    try:
        # https://pypi.python.org/pypi/joblib
        from joblib import Parallel, delayed

        # For progress output
        import joblib.parallel
        joblib.parallel.CallBack = CallBack


        # The worker
        time1 = time.time()
        def workerPARAMETRISE(q):
            s = ipols[q].toString()
            ipols[q] = 0
            return s
        # Parallel execution and collection of Ipol.toString
        results = Parallel(n_jobs=num_cores)(delayed(workerPARAMETRISE)(num) for num in xrange(len(ipols)))
        time2 = time.time()
        print '\nInterpolation took %0.2f s'%((time2-time1))
    except ImportError:
        print "Package joblib not available, no multithreading"
        results = defaultParam(ipols)

else:
    results = defaultParam(ipols)

# Open output file name
with open(args.output, "w") as f:
    writeMeta(f, params)

    # Write to file
    for r in results:
        f.write("%s\n"%r)
print 'Output written to %s'%args.output
