#! /usr/bin/env python

"""\
%prog datadir

Gradient calculation to display sensitivity to parameter shifts

%prog [<ipolfile>=ipol.dat]

"""

import optparse
op = optparse.OptionParser(usage=__doc__)
op.add_option("--wfile", dest="WFILE", default=None, help="Path to a weight file, used to restrict plotting to a subset of histograms (default: %default)")
op.add_option("-o", "--output", dest="OUTPUT", default="sensitivities", help="Output directory (default: %default)")
op.add_option("--debug", dest="DEBUG", action="store_true", default=False, help="Turn on some debug messages")
op.add_option("--quiet", dest="QUIET", action="store_true", default=False, help="Turn off messages")
# TODO: Add weight file parsing to decide which histos (and bin subsets) to interpolate
opts, args = op.parse_args()

## Read persisted interpolations to re-create the ipol Histos
import professor2 as prof
if not opts.QUIET:
    print prof.logo

import os, sys
if len(args) <1:
    print "No interpolation file given, exiting"
    sys.exit(1)

IFILE = args[0]
if not os.path.exists(IFILE):
    print "Error: specified interpolation file %s not found, exiting." % IFILE
    sys.exit(1)

## Read in meta data and ipol histos
META, IHISTOS = prof.read_ipolhistos(IFILE)

## Weight file parsing
if opts.WFILE:
    matchers = prof.read_pointmatchers(opts.WFILE)
    for hn in IHISTOS.keys():
        if not any(m.match_path(hn) for m in matchers.keys()):
            del IHISTOS[hn]
    if len(IHISTOS.keys())==0:
        print "Nothing left after weight file parsing, exiting"
        sys.exit(0)

## Center of the Parameter space
minPV = map(float, META["MinParamVals"].split())
maxPV = map(float, META["MaxParamVals"].split())
C = [minPV[i] + 0.5*(maxPV[i]-minPV[i]) for i in xrange(len(minPV))]

## Parameter names --- for labels and output file names
params = META["ParamNames"].split()

from numpy import array, linspace, empty, meshgrid

# Iterate over parameters
for P in xrange(len(C)):
    # Iterate over observables
    for k in sorted(IHISTOS.keys()):
        # Symmetric x (bins) and y (parmeter sub space) 
        x = array([b.xmid for b in IHISTOS[k].bins])
        y = linspace(minPV[P], maxPV[P], len(x))
        X, Y = meshgrid(x, y)
        Z = empty(X.shape)
        # Iterate over bins
        for i in xrange(len(X)):
            # C is where the derivative is evaluated.
            # We scan dimension i but set all parameters !=i to the center value
            C = [minPV[m] + 0.5*(maxPV[m]-minPV[m]) for m in xrange(len(minPV))]
            for j in xrange(len(Y)):
                c = minPV[P] + j/float(len(x))*(maxPV[P]- minPV[P])
                C[P] = c
                Z[j,i] = IHISTOS[k].bins[i].der(C) # The derivative

        # Plotting
        import matplotlib.pyplot as plt
        fig, ax = plt.subplots()

        # Colour limits
        from matplotlib import cm
        lim = max(abs(Z.max()), abs(Z.min()))
        cax = ax.imshow(Z, interpolation='nearest', cmap=cm.seismic, vmin=-lim, vmax=lim)
        cbar = fig.colorbar(cax, ticks=[-lim, 0, lim])

        # Ticks and labels
        xticki = [int(i) for i in ax.xaxis.get_ticklocs()[1:]]
        xtickl = [""]
        xtickl.extend(["%.3f"%x[i] for i in xticki if i <len(x)])
        ax.set_xticklabels(xtickl, rotation=270)
        yticki = [int(i) for i in ax.yaxis.get_ticklocs()[1:]]
        ytickl = [""]
        ytickl.extend(["%.3f"%y[i] for i in yticki if i <len(y)])
        ax.set_yticklabels(ytickl)
        ax.set_xlabel(k)
        ax.set_ylabel(params[P])

        # Nice and tight
        plt.tight_layout()

        # Output
        import os
        if not os.path.exists(opts.OUTPUT):
            os.makedirs(opts.OUTPUT)
        fig.savefig(os.path.join(opts.OUTPUT, "sens_%s_p%s.pdf"%(k.replace("/","_"), params[P])))
        plt.close(fig)
        del fig
