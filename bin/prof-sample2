#! /usr/bin/env python

"""\
%prog [-t template1.txt -t ...] PARAM1:low1:high1 PARAM2:low2:high2:'exp(x)'

Sample a parameter space, creating a set of parameter files and optionally
substituting into script templates, with either flat sampling (default) or
sampling in a transformed space.

TODO:
 * accept range file as input in addition to args
"""

import optparse
op = optparse.OptionParser(usage=__doc__)
op.add_option("-n", dest="NUMPOINTS", metavar="NUM", type=int, default=100, help="number of samples to generate [default=%default]")
op.add_option("-t", dest="TEMPLATES", metavar="FILE", action="append", default=[], help="specify a template file to be populated for each sample point. Can be given multiple times")
op.add_option("-o", "--outdir", dest="OUTDIR", metavar="DIR", default="scan", help="specify the output directory name (default: %default)")
op.add_option("-O", "--outmode", dest="OUTMODE", metavar="MODE", default="hier", help="specify the output structuring mode: either 'hier' (default) or 'flat' to respectively use run subdirs or not")
op.add_option("-p", "--pfile", dest="PARAMSFILE", metavar="FILE", default="params.dat", help="specify params file base name to be populated for each sample point")
op.add_option("-P", "--no-pfile", dest="PARAMSFILE", action="store_const", const=None, help="do not write a params file for each sample point")
op.add_option("-s", "--seed", dest="SEED", metavar="VAL", help="specify a random seed for the sampler (default: use system time)")
opts, args = op.parse_args()
assert opts.OUTMODE in ("hier", "flat")

import os

def mkrunstr(num):
    return "{run:04d}".format(run=num)

def mkoutname(fname, run, prefix="", suffix=""):
    if type(run) is int:
        run = mkrunstr(run)
    if opts.OUTMODE == "hier":
        name = os.path.join(run, fname)
    elif opts.OUTMODE == "flat":
        fname = os.path.basename(fname)
        base, ext = os.path.splitext(fname)
        name = prefix + base + "-" + run + suffix + ext
    return os.path.join(opts.OUTDIR, name)

def mkdir(path):
    d = os.path.dirname(path) #< if path is to a dir, make sure to terminate with a /
    if not os.path.exists(d):
        os.makedirs(d)

## Populate dict of script templates
TEMPLATES = {}
for t in opts.TEMPLATES:
    tname = os.path.basename(t)
    with open(tname, "r") as f:
        TEMPLATES[tname] = f.read()


## Initialise random number generator
import random
if opts.SEED:
    random.seed(opts.SEED)


## Define a sampler type
# TODO: Move this into a utils submodule
class Sampler(object):

    def __init__(self, low, high, bias=None):
        self.low = float(low)
        self.high = float(high)
        self.f, self.invf = None, None
        if bias:
            ## Import clever machinery
            try:
                import sympy as sp
                from sympy.abc import x, y
                import numpy as np
            except ImportError:
                print "Bias functions require SymPy and NumPy to be installed... exiting"
                exit(1) #< TODO: don't exit from inside a lib function...
            ## Make transformation and its inverse
            try:
                #print bias
                f_expr = sp.sympify(bias)
            except sp.SympifyError, e:
                print "Bias function could not be parsed by SymPy:"
                print e
                exit(1) #< TODO: don't exit from inside a lib function...
            try:
                finv_exprs = sp.solve(sp.Eq(y, f_expr), x)
                finv_expr = finv_exprs[0]
                #print f_expr, finv_exprs
                self.f = sp.lambdify(x, f_expr, "numpy")
                self.finv = sp.lambdify(y, finv_expr, "numpy")
                self.lowf, self.highf = self.f(self.low), self.f(self.high)
            except Exception, e:
                print "Bias function could not be used/inverted by SymPy:"
                print e
                exit(1) #< TODO: don't exit from inside a lib function...

    def shoot(self):
        if not self.f:
            ## Just uniform sampling between low..high
            val = random.uniform(self.low, self.high)
        else:
            ## Uniform sample in transformed space, and transform the result back
            valf = random.uniform(self.lowf, self.highf)
            val = self.finv(valf)
        return val

    def __call__(self):
        return self.shoot()

## Test biased sampler machinery
# s = Sampler(1, 10, "exp(x)")
# import yoda
# h = yoda.Histo1D(20, 0, 10)
# for _ in xrange(10000):
#     h.fill( s() )
# yoda.plot(h, "foo.pdf")


## Populate param samplers dictionary
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict
samplers = OrderedDict()
for a in args:
    argparts = a.split(":")
    # TODO: enforce arg format correctness
    name = argparts[0]
    sampler = Sampler(*argparts[1:])
    samplers[name] = sampler


## Do random param sampling and template instantiation
for n in xrange(opts.NUMPOINTS):
    npad = mkrunstr(n)

    ## Populate params dictionary
    params = OrderedDict()
    for name, s in samplers.iteritems():
        params[name] = s()

    ## Write params file if not disabled (by specifying a null filename)
    if opts.PARAMSFILE:
        pname = mkoutname(opts.PARAMSFILE, npad)
        mkdir(pname)
        with open(pname, "w") as pf:
            for k, v in params.iteritems():
                pf.write("{name} {val:e}\n".format(name=k, val=v))

    ## Instantiate template(s)
    params["N"] = npad #< Add the run number *after* writing out the params file
    for tbasename, tmpl in TEMPLATES.iteritems():
        txt = tmpl.format(**params)
        tname = mkoutname(tbasename, npad)
        mkdir(tname)
        with open(tname, "w") as tf:
            tf.write(txt)
